from __future__ import annotations

import json
import os
import re
import zipfile
from typing import Any, Dict, List, Optional
import datetime
import uuid

from .bond import BondObject
from .mapper import LoxoneEndpoint, LoxoneInput

def _slug(s: str) -> str:
    s = s.strip().lower()
    s = re.sub(r"[^a-z0-9]+", "_", s)
    s = re.sub(r"_+", "_", s).strip("_")
    return s or "x"
    
def _xml_escape(s: str) -> str:
    return (s.replace("&", "&amp;")
             .replace("<", "&lt;")
             .replace(">", "&gt;")
             .replace('"', "&quot;")
             .replace("'", "&apos;"))

def generate_lxaddon(
    *,
    host: str,
    token: str,
    bond_id: str,
    firmware: str,
    objs: List[BondObject],
    endpoints: List[LoxoneEndpoint],
    inputs: List[LoxoneInput],
    out_lxaddon_path: str,
    intermediate_dir: Optional[str],
    poll_interval: int
) -> Dict[str, Any]:

    desc = {
        "title": f"Bond Bridge Autogenerated - {bond_id}",
        "version": "0.3.0",
        "generated": True,
        "bond_id": bond_id,
        "bond_firmware": firmware,
        "generation_timestamp": datetime.datetime.utcnow().isoformat() + "Z",
        "host": host,
        "object_count": len(objs),
        "endpoint_count": len(endpoints),
        "input_count": len(inputs),
        "note": "This addon was autogenerated by bond2loxone.",
    }

    template_xml = _lox_template_xml(host, token, endpoints, inputs)

    # Build intermediate directory content.
    tmp_root = intermediate_dir
    if tmp_root is None:
        tmp_root = out_lxaddon_path + ".unpacked"
    
    # Only create intermediate dir if requested
    if intermediate_dir:
        os.makedirs(tmp_root, exist_ok=True)

        with open(os.path.join(tmp_root, "desc.json"), "w", encoding="utf-8") as f:
            json.dump(desc, f, indent=2, sort_keys=True)

        with open(os.path.join(tmp_root, "template.xml"), "w", encoding="utf-8") as f:
            f.write(template_xml)

        # Also dump a human-friendly inventory snapshot for inspection / debugging.
        inventory = {
            "bond_id": bond_id,
            "discovery_timestamp": desc["generation_timestamp"],
            "devices": [],
            "groups": []
        }
        
        for o in objs:
            item = {
                "kind": o.kind,
                "id": o.obj_id,
                "name": o.name,
                "type": o.obj_type,
                "location": o.location,
                "actions": [k for k, _ in o.actions_raw.items()] if isinstance(o.actions_raw, dict) else o.actions_raw,
                "state": o.state,
                "members": o.members,
            }
            if o.kind == "DEVICE":
                inventory["devices"].append(item)
            else:
                inventory["groups"].append(item)
                
        with open(os.path.join(tmp_root, "inventory.json"), "w", encoding="utf-8") as f:
            json.dump(inventory, f, indent=2, sort_keys=False)

    # Zip into .LxAddon
    os.makedirs(os.path.dirname(out_lxaddon_path) or ".", exist_ok=True)
    with zipfile.ZipFile(out_lxaddon_path, "w", compression=zipfile.ZIP_DEFLATED) as z:
        z.writestr("desc.json", json.dumps(desc, indent=2, sort_keys=True))
        z.writestr("template.xml", template_xml)
        # We don't include inventory.json in the final addon as Loxone doesn't use it

    return {"desc": desc, "intermediate_dir": tmp_root if intermediate_dir else None, "out": out_lxaddon_path}

def _lox_template_xml(host: str, token: str, endpoints: List[LoxoneEndpoint], inputs: List[LoxoneInput]) -> str:
    lines: List[str] = []
    lines.append('<?xml version="1.0" encoding="utf-8"?>')
    lines.append('<LoxoneTemplate xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">')
    lines.append('  <Meta>')
    lines.append('    <Title>Bond Bridge Autogenerated Interface</Title>')
    lines.append('    <Description>Autogenerated Virtual Outputs for all Bond actions.</Description>')
    lines.append('  </Meta>')
    
    lines.append('  <VirtualOutputs>')
    for e in endpoints:
        # Naming convention: {device_type}_{location}_{name}_{action}
        # e.g. ms_living_room_shade_open
        obj_prefix = f"{_slug(e.kind)}_{_slug(e.obj_location)}_{_slug(e.obj_name)}"
        # Shorten kind
        if e.kind == "DEVICE": obj_prefix = f"dev_{_slug(e.obj_location)}_{_slug(e.obj_name)}"
        if e.kind == "GROUP": obj_prefix = f"grp_{_slug(e.obj_location)}_{_slug(e.obj_name)}"
        
        vo_name = f"{obj_prefix}_{_slug(e.action_canon)}"
        
        path = f"/v2/{'devices' if e.kind == 'DEVICE' else 'groups'}/{e.obj_id}/actions/{e.action_key}"
        url = f"http://{host}{path}"

        if e.type == "analog":
            # Loxone typically substitutes the value of the VO in the command string.
            # We'll use <v> placeholder
            
            # Handle inversion if needed
            val_expr = "<v>"
            if e.invert:
                # Loxone doesn't support math in command, so we rely on Loxone Config correction
                # But we can note it
                pass

            payload = {"_token": token, "argument": "__VAL__"}
            # We need to replace "__VAL__" with <v> unquoted, so we do string manipulation
            json_body = json.dumps(payload).replace('"__VAL__"', "<v>")
            
            cmd = f"curl -s -X PUT {json.dumps(url)} -H 'Content-Type: application/json' -d '{json_body}'"
        else:
            payload = {"_token": token}
            cmd = f"curl -s -X PUT {json.dumps(url)} -H 'Content-Type: application/json' -d {json.dumps(json.dumps(payload))}"

        lines.append('    <VO>')
        lines.append(f'      <Name>{_xml_escape(vo_name)}</Name>')
        lines.append(f'      <Type>{e.type}</Type>')
        lines.append(f'      <Command>{_xml_escape(cmd)}</Command>')
        lines.append(f'      <Note>{_xml_escape(e.description)}</Note>')
        lines.append('    </VO>')
    lines.append('  </VirtualOutputs>')

    if inputs:
        lines.append('  <VirtualInputs>')
        for i in inputs:
            obj_prefix = f"dev_{_slug(i.obj_location)}_{_slug(i.obj_name)}"
            if i.kind == "GROUP": obj_prefix = f"grp_{_slug(i.obj_location)}_{_slug(i.obj_name)}"
            
            vi_name = f"{obj_prefix}_state_{_slug(i.state_key)}"
            
            path = f"/v2/{'devices' if i.kind == 'DEVICE' else 'groups'}/{i.obj_id}/state"
            url = f"http://{host}{path}"
            
            # For inputs, we use GET
            # Note: Loxone Virtual Inputs usually poll via http
            # We construct a command that fetches state
            
            # Loxone HTTP input command format is tricky. 
            # Usually it's <Command>URL</Command> and <Polling>interval</Polling>
            # And then parsing is done via <CommandParsing>
            
            # However, for a template, we often define the VI and let user configure parsing
            # Or we provide a command that returns the value.
            
            # Since we are using curl for outputs, we can use curl for inputs if using Virtual Input (HTTP)
            # But standard Virtual Inputs in Loxone are often passive or simple HTTP pollers.
            
            # Let's assume standard HTTP polling VI
            cmd = f"curl -s -X GET {json.dumps(url)} -H 'Content-Type: application/json' -d {json.dumps(json.dumps({'_token': token}))}"
            
            lines.append('    <VI>')
            lines.append(f'      <Name>{_xml_escape(vi_name)}</Name>')
            lines.append(f'      <Type>{i.type}</Type>')
            lines.append(f'      <Command>{_xml_escape(cmd)}</Command>')
            lines.append(f'      <Polling>{i.poll_interval}</Polling>')
            # We can hint at parsing
            lines.append(f'      <Note>{_xml_escape(i.description)} (Parse JSON key: {i.state_key})</Note>')
            lines.append('    </VI>')
        lines.append('  </VirtualInputs>')

    lines.append('</LoxoneTemplate>')
    return "\n".join(lines)
