from __future__ import annotations

import json
import os
import re
import zipfile
from typing import Any, Dict, List, Optional
import datetime
import uuid

from .bond import BondObject
from .mapper import LoxoneEndpoint, LoxoneInput

def _slug(s: str) -> str:
    s = s.strip().lower()
    s = re.sub(r"[^a-z0-9]+", "_", s)
    s = re.sub(r"_+", "_", s).strip("_")
    return s or "x"
    
def _xml_escape(s: str) -> str:
    return (s.replace("&", "&amp;")
             .replace("<", "&lt;")
             .replace(">", "&gt;")
             .replace('"', "&quot;")
             .replace("'", "&apos;"))

def _generate_uuid(bond_id: str, suffix: str) -> str:
    # Create a deterministic UUID based on Bond ID and a suffix (e.g. 'outputs' or 'inputs')
    # We use a custom namespace for bond2loxone
    namespace = uuid.uuid5(uuid.NAMESPACE_DNS, "bond2loxone.com")
    return str(uuid.uuid5(namespace, f"{bond_id}-{suffix}"))

def generate_lxaddons(
    *,
    host: str,
    token: str,
    bond_id: str,
    firmware: str,
    objs: List[BondObject],
    endpoints: List[LoxoneEndpoint],
    inputs: List[LoxoneInput],
    out_dir: str,
    intermediate_dir: Optional[str],
    poll_interval: int
) -> Dict[str, Any]:
    
    results = {}
    
    # Ensure output directory exists
    os.makedirs(out_dir, exist_ok=True)

    # --- Generate Outputs Addon ---
    if endpoints:
        filename_base = f"bond2loxone-autogenerated-{bond_id}-outputs"
        xml_filename = f"{filename_base}.xml"
        
        # Generate UUID
        addon_uuid = _generate_uuid(bond_id, "outputs")
        
        desc = {
            "type": "template",
            "name": f"Bond {bond_id} (Outputs)",
            "uuid": addon_uuid,
            "version": "1.0.0",
            "id": f"bond-{bond_id}-outputs",
            "file": xml_filename,
            "templateType": "3", # Virtual Out
            # Extra metadata (ignored by Loxone but useful)
            "bond_id": bond_id,
            "bond_firmware": firmware,
            "generated_by": "bond2loxone",
            "generation_timestamp": datetime.datetime.utcnow().isoformat() + "Z",
        }

        xml_content = _lox_template_xml_outputs(host, token, bond_id, endpoints)
        
        # Intermediate files
        if intermediate_dir:
            out_int_dir = os.path.join(intermediate_dir, "outputs")
            os.makedirs(out_int_dir, exist_ok=True)
            with open(os.path.join(out_int_dir, "desc.json"), "w", encoding="utf-8") as f:
                json.dump(desc, f, indent=2, sort_keys=True)
            with open(os.path.join(out_int_dir, xml_filename), "w", encoding="utf-8") as f:
                f.write(xml_content)

        # Zip
        zip_path = os.path.join(out_dir, f"{filename_base}.LxAddon")
        with zipfile.ZipFile(zip_path, "w", compression=zipfile.ZIP_DEFLATED) as z:
            z.writestr("desc.json", json.dumps(desc, indent=2, sort_keys=True))
            z.writestr(xml_filename, xml_content)
            
        results["outputs"] = zip_path

    # --- Generate Inputs Addon ---
    if inputs:
        filename_base = f"bond2loxone-autogenerated-{bond_id}-inputs"
        xml_filename = f"{filename_base}.xml"
        
        # Generate UUID
        addon_uuid = _generate_uuid(bond_id, "inputs")
        
        desc = {
            "type": "template",
            "name": f"Bond {bond_id} (Inputs)",
            "uuid": addon_uuid,
            "version": "1.0.0",
            "id": f"bond-{bond_id}-inputs",
            "file": xml_filename,
            "templateType": "1", # Virtual In (HTTP)
            # Extra metadata
            "bond_id": bond_id,
            "bond_firmware": firmware,
            "generated_by": "bond2loxone",
            "generation_timestamp": datetime.datetime.utcnow().isoformat() + "Z",
        }

        xml_content = _lox_template_xml_inputs(host, token, bond_id, inputs, poll_interval)
        
        # Intermediate files
        if intermediate_dir:
            out_int_dir = os.path.join(intermediate_dir, "inputs")
            os.makedirs(out_int_dir, exist_ok=True)
            with open(os.path.join(out_int_dir, "desc.json"), "w", encoding="utf-8") as f:
                json.dump(desc, f, indent=2, sort_keys=True)
            with open(os.path.join(out_int_dir, xml_filename), "w", encoding="utf-8") as f:
                f.write(xml_content)

        # Zip
        zip_path = os.path.join(out_dir, f"{filename_base}.LxAddon")
        with zipfile.ZipFile(zip_path, "w", compression=zipfile.ZIP_DEFLATED) as z:
            z.writestr("desc.json", json.dumps(desc, indent=2, sort_keys=True))
            z.writestr(xml_filename, xml_content)
            
        results["inputs"] = zip_path

    return results

def _lox_template_xml_outputs(host: str, token: str, bond_id: str, endpoints: List[LoxoneEndpoint]) -> str:
    lines: List[str] = []
    lines.append('<?xml version="1.0" encoding="utf-8"?>')
    # VirtualOut root
    # Address: http://HOST
    lines.append(f'<VirtualOut Title="Bond {bond_id}" Comment="Autogenerated by bond2loxone" Address="http://{host}" CmdInit="" CloseAfterSend="true">')
    lines.append('  <Info templateType="3" minVersion="12031214"/>')
    
    for e in endpoints:
        # Naming: Location Device Action
        # e.g. "Living Room Shade Open"
        title = f"{e.obj_location} {e.obj_name} {e.action_key}"
        
        path = f"/v2/{'devices' if e.kind == 'DEVICE' else 'groups'}/{e.obj_id}/actions/{e.action_key}"
        
        # Construct payload
        if e.type == "analog":
            # <v> placeholder for value
            payload = {"_token": token, "argument": "__VAL__"}
            json_body = json.dumps(payload).replace('"__VAL__"', "<v>")
            # For analog, we need to be careful with XML escaping of the JSON body if it contains quotes
            # But json.dumps escapes quotes with backslash, which isn't XML safe directly in attribute
            # We need to XML escape the whole attribute value.
            # Loxone expects: CmdOnPost="&lt;json...&gt;"
            
            # Actually, json.dumps produces "key": "value".
            # In XML attribute: CmdOnPost="{&quot;key&quot;: ...}"
            
            # Let's prepare the raw string first
            raw_post = json_body
        else:
            payload = {"_token": token}
            raw_post = json.dumps(payload)

        # XML Escape the attribute values
        cmd_post_esc = _xml_escape(raw_post)
        
        # Build the VirtualOutCmd
        # CmdOnMethod="PUT"
        # CmdOn="/v2/..."
        # CmdOnPost="..."
        
        # Analog handling
        analog_attrs = ""
        if e.type == "analog":
            analog_attrs = ' Analog="true" SourceValHigh="100" DestValHigh="100"'
            # If inverted, we might want to swap Source/Dest or rely on user config.
            # For now, simple 0-100 mapping.
        
        lines.append(f'  <VirtualOutCmd Title="{_xml_escape(title)}" Comment="{_xml_escape(e.description)}" CmdOnMethod="PUT" CmdOn="{path}" CmdOnPost="{cmd_post_esc}"{analog_attrs}/>')

    lines.append('</VirtualOut>')
    return "\n".join(lines)

def _lox_template_xml_inputs(host: str, token: str, bond_id: str, inputs: List[LoxoneInput], poll_interval: int) -> str:
    lines: List[str] = []
    lines.append('<?xml version="1.0" encoding="utf-8"?>')
    # VirtualInHttp root
    lines.append(f'<VirtualInHttp Title="Bond {bond_id} Status" Comment="Autogenerated by bond2loxone" Address="http://{host}" Polling="{poll_interval}">')
    lines.append('  <Info templateType="1" minVersion="12031214"/>')
    
    for i in inputs:
        title = f"{i.obj_location} {i.obj_name} {i.state_key}"
        path = f"/v2/{'devices' if i.kind == 'DEVICE' else 'groups'}/{i.obj_id}/state"
        
        # Parsing logic
        # We need to match the JSON key.
        # Loxone parsing: \i"key":\i\v
        # Example: "open": 1  -> \i"open":\i\v
        # Example: "position": 50 -> \i"position":\i\v
        
        # We assume the state key is simple (no nested objects for now, as Bond state is flat)
        parse_str = f'\\i"{i.state_key}":\\i\\v'
        
        # Analog vs Digital
        analog_attrs = ""
        if i.type == "analog":
            analog_attrs = ' Analog="true"'
        
        lines.append(f'  <VirtualInHttpCmd Title="{_xml_escape(title)}" Comment="{_xml_escape(i.description)}" Cmd="{path}" Check="{_xml_escape(parse_str)}"{analog_attrs}/>')

    lines.append('</VirtualInHttp>')
    return "\n".join(lines)

